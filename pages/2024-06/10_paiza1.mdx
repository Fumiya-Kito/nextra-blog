# Paiza Bランク
スキルチェックをしていて勉強になっているが、流出されるわけにはいかないので問題集をやる

### 問題
東京の下町に長テーブルで有名な老舗うなぎ屋がありました。

そのうなぎ屋にはとても大きい長テーブルがあり、テーブルの周りにn個の座席が配置されています。
座席には、時計回りに1, 2, …, nと番号が振られています。
座席はテーブルの周りに配置されているので、座席番号nの座席と1の座席は隣接しています。（下記図を参照の事）


今、m個のグループの人達が座席に順番に座りに来ます。i番目(1≦i≦m)のグループの人数をa_i人とします。
彼らは、長テーブルに並んだ座席の内、ある連続するa_i個の座席に一斉に座ろうとします。

ただしお客さんは江戸っ子なので、それら座席のうち、いずれか一つでも既に先客に座られている座席があった場合、
一人も座らずにグループ全員で怒って帰ってしまいます。江戸っ子は気が早いんでぃ。

入力では、i番目のグループが座ろうとする連続した座席の位置は、整数b_iにより指定されます。
i番目のグループは、座席番号b_iの座席を始点として、そこから時計回りにa_i個分の座席に座ろうとします。

最後のグループが座りに来た後、無事に長テーブルの座席に着席出来ている人数を出力するプログラムを作成してください。

### 入力
入力はm+1行から成ります。
1行目にはn(座席数)とm(グループ数)が半角スペース区切りで入力されます。
i+1行目(1≦i≦m)には2個の整数a_i(グループの人数)とb_i(着席開始座席番号)が半角スペース区切りで入力されます。



### 期待する出力
最後のグループが座りに来た後、無事に座席に着席出来ている人数を1行で出力してください。


```cpp
#include <iostream>
#include <vector>

int main() {
    int n, m;
    std::cin >> n >> m;
    std::vector<bool> seats(n, false); // 座席が埋まっているかどうかを追跡するベクトル
    int total_seated = 0;

    for (int i = 0; i < m; i++) {
        int a_i, b_i;
        std::cin >> a_i >> b_i;
        bool can_seat = true;
        // 座席番号を0から始めるために調整(問題は1から、配列は0から、循環するため余り)
        int start = (b_i - 1) % n;

        // グループが座ろうとする座席をチェック
        for (int j = 0; j < a_i; j++) {
            if (seats[(start + j) % n]) {
                can_seat = false;
                break;
            }
        }

        // 座席が空いていれば、グループを座らせる
        if (can_seat) {
            for (int j = 0; j < a_i; j++) {
                seats[(start + j) % n] = true;
            }
            total_seated += a_i;
        }
    }

    std::cout << total_seated << std::endl;

    return 0;
}
```