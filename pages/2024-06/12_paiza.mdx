神経衰弱と呼ばれるトランプゲームのシミュレーションをしましょう。
今回は数字が書かれたトランプのみを考え、ジョーカーは考えません。

まず、トランプを縦 H 枚、横 W 枚の長方形の形に並べた状態でスタートします。
H × W 枚のトランプには 1 〜 13 の数字のうちどれか1つが書かれています。
また、同じ数字が書かれたトランプが複数あります。

プレイヤーが N 人おり、それぞれ 1 〜 N で番号付けられています。
ゲームが始まると、1番の人から、このような手順でプレイしていきます。

・並べられたトランプから2枚のトランプを選び、めくります。
・めくった2枚のトランプに異なる数字が書かれていれば、次のプレイヤーの手番となります。同じ数字であれば、次の操作をおこないます。
・まず、2枚のトランプはめくったプレーヤーのものとなり、取り除かれます。
・トランプがすべて取り除かれた場合、ゲームは終了となります。
・トランプが残っている場合、同じプレーヤーがまた最初の手順に戻り、トランプをめくります。

ここで、N 番のプレイヤーの次のプレイヤーは 1 番のプレイヤーであるとします。

ゲームの初期状態におけるトランプの配置と、ゲームが終わるまでに捲られたトランプに関する時系列順の記録が与えられます。
その記録を用いて、各プレイヤーが取り除いたトランプの枚数を求めてください。

たとえば、入力例1は以下のようになります。



## 入力
入力は以下のフォーマットで与えられます。

```
H W N
t_{1,1} t_{1,2} ... t_{1,W}
t_{2,1} t_{2,2} ... t_{2,W}
...
t_{H,1} t_{H,2} ... t_{H,W}
L
a_1 b_1 A_1 B_1
a_2 b_2 A_2 B_2
...
a_L b_L A_L B_L
```

1行目には3つの整数 H, W, Nが入力されます。
H と W はそれぞれ並べられたトランプの縦方向の枚数と横方向の枚数で、N はプレイヤーの数を表します。

続く H 行には、配置されたトランプに書かれた数字が入力されます。
t_{i,j} は i 行 j 列に置かれたトランプに書かれた数字を表します。

次の行には、記録の長さ L が与えられます。

続く L 行には、捲られたトランプの記録が時系列順で与えられます。
これは、a_i 行 b_i 列のトランプと A_i 行 B_i 列のトランプが捲られたことを表します。


## 期待する出力
i 行目には i 番目のプレイヤーが取り除いたトランプの枚数を出力してください。
各行の最後は改行し、余計な文字、空行を含んではいけません。

### 例
```a filename="入力例"
2 3 2
1 2 3
2 1 3
5
1 1 2 1
1 1 1 2
1 1 2 2
1 3 2 3
1 2 2 1
```
```a filename="出力"
6
0
```

## 
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    // 高さ,幅,人数を受け取る
    int H, W, N;
    cin >> H >> W >> N;

    // トランプの配置を受け取る
    vector<vector<int>> board(H, vector<int>(W));
    for (int i = 0; i < H; ++i) {
        for (int j = 0; j < W; ++j) {
            cin >> board[i][j];
        }
    }

    // ターン数を受け取る
    int L;
    cin >> L;

    // 取られたトランプ配置を記憶する２次元配列とスコアを記録する配列を用意
    vector<vector<bool>> removed(H, vector<bool>(W, false));
    vector<int> scores(N, 0);

    // シミュレーション開始
    int currentPlayer = 0;

    for (int k = 0; k < L; ++k) { //ターン数を走査
        int a, b, A, B; // 捲られた座標
        cin >> a >> b >> A >> B;
        a--; b--; A--; B--;  // 座標を0-indexに変換

        // 一致した場合、スコアリングと配置を記録
        if (board[a][b] == board[A][B]) {
            scores[currentPlayer] += 2;
            removed[a][b] = true;
            removed[A][B] = true;
        } else {
            currentPlayer = (currentPlayer + 1) % N;
        }
    }

    for (int i = 0; i < N; ++i) {
        cout << scores[i] << endl;
    }

    return 0;

}

```