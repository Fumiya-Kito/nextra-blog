## 問題
このチャプターでは、グラフ理論における根付き木を扱います。
根付き木とは、以下の図のような n 個の頂点と、それらを連結する n-1 個の辺と頂点のうち、根と呼ばれる 1 つの特別な頂点からなるグラフのことです。

根付き木では、根である頂点を一番上に固定することで、2 つの頂点間に上下の関係を与えることができます。辺で結ばれた 2 つの頂点 A , B について、より根に近い方の頂点はもう一方の頂点の親といいます。また、根から遠い方の頂点はもう一方の頂点の子といいます。

```a filename="by ChatGPT"
グラフ理論における根付き木（ねつきぎ、rooted tree）とは、以下の条件を満たす木（ツリー）です。

木（ツリー）：グラフの一種であり、連結で閉路（サイクル）を持たないもの。
根（ルート）：特定の頂点を1つ指定する。この指定された頂点を根（ルート）と呼びます。
根付き木の特徴は次の通りです：

方向性：根付き木では、根から他のすべての頂点へ向かう道が一意に定まるため、各辺には根から遠ざかる方向が自然に定まります。
レベル（高さ）：根からの距離に基づいて各頂点のレベル（高さ）が定義されます。根はレベル0で、その隣接頂点はレベル1、さらにその隣接頂点はレベル2、というように続きます。
親子関係：各頂点には1つの親頂点と0個以上の子頂点があります。ただし、根には親がありません。
部分木：任意の頂点を根とする部分グラフもまた根付き木になります。
具体的な例を挙げると、組織の階層構造やファイルシステムのディレクトリ構造などが根付き木としてモデル化されます。

このように、根付き木は構造が明確で、様々なアルゴリズムの基盤となる重要な概念です。
```


根付き木の頂点や辺を親子関係がわかる形式で管理するには、普通の木と同様に隣接行列や隣接リストで管理する方法では上手くいきません。
各頂点について構造体を用意し、親子の頂点を記憶したり、辺に接続する 2 つの頂点のどちらが親かがわかるように辺の管理方法を工夫する必要があります。

根付き木の頂点・辺についての情報と K 個の頂点が与えられるので、与えられた各頂点の子の頂点番号を昇順で全て出力してください。

## 入力される値
```
N K R
a_1 b_1
...
a_{N-1} b_{N-1}
v_1
...
v_K
```
- 1 行目には、根付き木の頂点の数 N, 与えられる頂点の数 K, 根付き木の根の頂点番号 R が与えられます。
- 続く N-1 行では、根付き木の各辺の両端の頂点 a_i , b_i が与えられます。ただし、a_i が b_i の親になります。(1 ≦ i ≦ N-1)
- 続く K 行では、子の頂点を求めたい頂点の番号 v_i が与えられます。(1 ≦ i ≦ K)

## 期待する出力
- K 行出力してください。
- i 行目に v_i の全ての子の頂点番号を昇順に半角スペース区切りで出力してください。(1 ≦ i ≦ K)
- 子の頂点が存在しない場合は改行のみを出力してください。

## 入力例1
```
4 2 1
1 2
1 3
2 4
1
2
```

## 出力例1
```
2 3
4
```


## 回答
```js
process.stdin.resume();
process.stdin.setEncoding('utf8');

var lines = [];
var reader = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
});
reader.on('line', (line) => {
  lines.push(line);
});
reader.on('close', () => {
  // N K Rの受け取り
  const [N, K, R] = lines[0].split(' ').map(Number);

  // 辺情報を親のみの隣接リストに格納
  const adjList = [...Array(N)].map(() => []);
  for (let i = 1; i < N; i++) {
    const [parent, child] = lines[i].split(' ').map(Number);
    adjList[parent - 1].push(child);  
  }

  
  // 求めたい頂点情報を取得・出力
  for (let i = 0; i < K; i++) {
    const rowNum = N + i;
    let vNum = lines[rowNum]; // 1, 2 入力通り
    let parentIdx = vNum - 1; // 0, 1 zeroIdx
    
    console.log(adjList[parentIdx].sort((a, b) => a - b).join(' '));
  }
});

```