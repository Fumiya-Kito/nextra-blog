# SQL を速くするインデックス入門 【B-Tree, 複合インデックス】

### 参考
[SQL を速くするインデックス入門 : B-Tree や複合インデックスが理解できる(Youtube)](https://www.youtube.com/watch?v=OsIxUT7D728&t=2501s)


# インデックスとは
```sql
select * from User where name = "z-man"
```
- インデックスがない場合上から順に見ていく(線形探索N回探す`O(N)`)
- インデックスを貼ると一文字目だけ`a→b→c...`とデータを飛ばして辞書的に探す(N回以下になる)


# B-Tree
- Balanced Tree: 二分探索木構造でノードの階層構造が全ての要素で同じになり、計算量(`O(logN)`)が変化しない
### B-Treeの基本構造
- ルートノード (Root Node): ツリーの一番上にあるノードです。
- 内部ノード (Internal Nodes): ルートノードの下にある中間ノードです。(ブランチノードともいう)
- 葉ノード (Leaf Nodes): ツリーの一番下にあるノードで、データを格納します。
### B-Treeの特性
- 各ノードは複数のキーを持ちます。
- 各ノードには複数の子ノードがあります。
- すべての葉ノードは同じ深さにあります。
- 各ノードには少なくともt-1個のキーがあり、多くとも2t-1個のキーがあります（tはB-Treeの最小次数）。

```css
             [20, 40]
          /      |       \
   [10, 15]  [25, 30, 35]  [50, 60, 70]
   /  |  \      /   |   \        /  |  \
[5] [12] [18] [22] [27] [33] [45] [55] [65] [75]
```

- ルートノードに2つのキー（20, 40）があり、3つの子ノードを持っています。
- 各子ノードにそれぞれ異なる数のキーが含まれています。
- すべての葉ノードが同じ深さにあります。


# B+Tree
- B-Treeのリーフノードの部分が横に連結している、再探索時に一階層上に戻る必要がない
- リーフノードにすべてのデータがあることが違い（B-Treeは１階層分しか存在しない）

## リーフノードは実データへのポインタ
- リーフノードは`rowPk`をポインタのように持っている
- `select rowPk from someTable`だとインデックス情報だけでレスポンスでき高速になる（実テーブルを見に行かない）


## インデックスをはる
```sql
ALTER TABLE items ADD INDEX idx_item_id(item_id)
```

# 複合インデックス
- メーカー名と商品Noでインデックスを貼る
```sql
ALTER TABLE items ADD INDEX idx_item_id(メーカー名, 商品No)
```
- カラム順が重要
- メーカー名の単体と(メーカー名, 商品No)の複合インデックスのTree構造はほぼ同じ
- 同じメーカーの商品がたくさん増えると複合のメリットを感じられるようになる
```sql filename="複合が使える"
SELECT * FROM 商品 
WHERE メーカー名 = "A" AND 商品No = "03"


SELECT * FROM 商品 
WHERE メーカー名 = "A" -- 最初のカラムのため
```

```sql filename="複合が使えない"
SELECT * FROM 商品 
WHERE 商品No = "03" -- 最初のカラムではないため結局全部(違うメーカーも)探しにいってしまう
```

## インデックスの誤解
- NULLはインデックスが使えない→使える
- NOT INはインデックスが使えない→使える
- 否定系はインデックスが使えない→使える
- WHEREの条件順はインデックスのカラム順でないといけない→オプティマイザが最適化するため気にしなくて良い
- LIKEはインデックスが使えない→ワイルドカードまでは使える(`LIKE 'ru%'`, `LIKE '%ru%'`→使えない)

# どこにはるか？
- 選択性(Cardinality)が高いもの=種類が多いものを優先すべき
- フラグ、性別など2,3種類のものはCardinalityが低い
- pkや更新日時などはCardinalityが高い(絞り込みが早い)
- ただし、データ分布に依存するため実際には検証しながら最適化することが一般的


### EXPLAIN
- 効率化したいSQLの前に`EXPLAIN`を加えることで、SQLの実行計画を見れる(計画で実際には違う可能性あり)
- `key`がつかうであろうインデックス
```sql
EXPLAIN SELECT * FROM テーブル;
```
