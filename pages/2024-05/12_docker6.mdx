# Volumes
- コンテナ内でデータを管理する方法を学ぶ

## データの種類
1. images & Enviroment
- ソースと環境はイメージレイヤに保存されるためREADONLY
2. container
- コンテナレイヤーのデータは一時的にキャッシュされるだけでシャットダウンすると消える
- Volumesを使うとデータを恒久化できる

|アプリケーション(ソース+環境)|アプリの一時的なデータ|アプリの恒久的なデータ|
|---|---|---|
|開発者によって提供|コンテナ起動時に作成・取得される|コンテナ起動時に作成・取得される|
|ビルドフェーズにできる|メモリor一時的なファイルに書き込まれる|DBまたはファイルに書き込まれる|
|ビルドが完了したら不変|動的に変更される|コンテナ削除時に消えるべきでない|
|imagesに保存(RO)|containerに保存される(R&W)|containerとvolumesに保存される(R&W)|


- 「アプリの一時的なデータ」はコンテナを停止しただけで消えないが、コンテナを削除して再作成すると消える
- 単に停止したものはREAD可能である


## Volumes
- ドッカーがデータを永続化させるために提供してくれている機能
- Volumesは「ホストマシン上のファイル」でも「container」でも「images」でもない
- 「ホストマシンのストレージのどこか(Dockerが管理して開発者は分からない)」が実態であり、コンテナにマウントされマッピングされることでコンテナ内で利用可能

## 名前付きと匿名のvolumes
- 匿名Volumesは特定のコンテナにアタッチされる
- 名前付きVolumesはどのコンテナからもアクセス可能
```dockerfile filename="dockerfile(匿名Volume)"
FROM node:14

WORKDIR /app

COPY package.json .

RUN npm install

COPY . .

EXPOSE 80

VOLUME [ "/app/feedback" ]

CMD [ "node", "server.js" ]
```
- build
```sh
docker build -t feedback-node:volumes .

# 試す
docker run -d -p 3000:80 --rm feedback-node:volumes
```
- **匿名Volumeは特定のコンテナにアタッチするもの**で再起動すると消えてしまう

```dockerfile filename="dockerfile"
## Dockerfileでは指定せず起動時に指定する
FROM node:14

WORKDIR /app

COPY package.json .

RUN npm install

COPY . .

EXPOSE 80

CMD [ "node", "server.js" ]
```
- `-v`タグを利用する
```sh
docker run -d -p 3000:80 --rm --name feedback-app -v feedback:/app/feedback feedback-node:volumes 

# syntax
-v <VolumeName>:<ContainerPath>
```

- 名前付きVolumeを確認する
```sh
docker stop <ContainerName>
docker volume ls

DRIVER    VOLUME NAME
local     feedback
```
- 同じVolumeを指定して起動すれば、共有できる
```
docker run -d -p 3000:80 --rm --name feedback-app -v feedback:/app/feedback feedback-node:volumes
```

# Bind Mounts
- Bind Mounts = 開発者が管理するファイルシステム
- BindMountsなら、コンテナはホストマシンのコードのファイルを理解することができる
- ↑コンテナ内部のパスをホストマシンにマッピングすべきパスに設定するから(pathを対応させるということ)

### メリット
- volumesはドッカーが管理し、imagesからソースコードを実行するため、変更を反映させるにはimagesの再起動が必要
- 対して、Bind Mountsであれば、ホストマシン上のソースのスナップショットをコンテナが把握し反映してくれる

### 使用方法
- volumesの時に比べ、もう一個ボリュームを指定する
- コロンの左側＝ホストマシンのファイルパスは、絶対パスで指定
- Dockerfileのプロジェクトパスで終わること
- 特殊文字で壊れないように`””`で囲む

```sh 
docker stop feedback-app

# ※コンテナパス＝`/app`
docker run -d -p 3000:80 --rm --name feedback-app -v feedback:/app/feedback -v "/Users/fumiya/Downloads/data-volumes-03-adj-node-code:/app" feedback-node:volumes

# または以下でパスを取得しても良い
-v $(pwd):/app
# for windows
-v "%cd%":/app
```
**※DockerDesktop環境設定でFileSharingがオンになっている必要がある**

## Combining & Merging Different Volumes
- 実は上記ではBind Mountsは使えない
```sh filename="実際には匿名ボリュームをもう一つ（app/node_modules）追加する必要がある"
docker run -d -p 3000:80 --rm --name feedback-app -v feedback:/app/feedback -v $(pwd):/app -v /app/node_modules feedback-node:volumes
```
### (問題点)
- コンテナを作成時にバインドマウントがあると、npm install からファイルコピーまでが無意味になる
- ↑バインドマウントにはnode_modulesが存在しないから
- コンテナ作成時にimagesでコピーしたものを全て上書きしてしまう
- node_modulesだけを除外すれば(バインドの管轄外に)アプリは起動する
- 現状名前付きボリュームとバインドマウンツが混在
    - コンテナ側からホストマシンのソースを変更できないようにDockerが制御
- 匿名ボリュームをもう一つ（app/node_modules）追加する
    - 名前が長く具体的な方が優先される
    - こうすることで、Dockerはappフォルダーにマップされたボリュームと
    - app/node_modules にマップされたボリュームを認識
    - node_moduels だけいじられないようになる（除外）
        - （Volumesを別々で認識してくれる）

### 特典
- HTMLの変更が即時反映され開発効率UP
- JSはWebサーバーnodeJSの再起動が必要だがコンテナの一部だけ再起動するのは難しい
- `nodemon`をパッケージインストールすることで解決する

