# ポインタ2

## スタック領域とヒープ領域
- 変数を使うにはその分のメモリが必要で、「必要→割り当て、不要→解放」という管理が必要
- ある程度はコンパイラが自動で管理してくれる

## メモリ領域の分類
三種類ある
- 静的領域
- スタック領域
- ヒープ領域


### 静的領域
- グローバル変数はプログラムの開始から終了までずっと有効な変数なので、 ずっとメモリ上に割り当てられている必要がある
- プログラム開始時に割り当てられて終了時に解放されればよいので、 グローバル変数のメモリ割り当て・解放はコンパイラによって自動的に行われる
- このときに**グローバル変数が配置されるメモリ領域を静的領域**という

### スタック領域
- ローカル変数はスコープ始まりでメモリを確保、スコープ終わりでメモリを解放する
- コンパイラによって自動で行われる
- ローカル変数が配置される**メモリ領域をスタック領域**という

### ヒープ領域
- スコープの範囲を超えて扱いたい情報を保持したいときに利用するメモリ領域がヒープ領域
- 柔軟に使える分、プログラマが割り当て、解放を行う必要がある
- ポインタを介して読み書きを行う必要がある

> ヒープ領域はメモリを有効活用したい場合のためのものです。 メモリ有効活用する必要のない場合は、予めグローバル変数として必要な分だけメモリを確保しておけば十分なことが多いです。


## ヒープ領域の確保
```cpp filename="メモリ確保"
型 *ポインタ1 = new 型;        // 1つ分の領域を確保
型 *ポインタ2 = new 型(引数);   // 1つ分の領域を確保(コンストラクタに引数を渡す)
型 *ポインタ3 = new 型[n];     // 連続したn個分の領域を確保
```

- ヒープ領域から確保したメモリは、明示的に解放しない限り、プログラムが終了するまで残り続けます。

```cpp filename="メモリの解放"
delete ポインタ1;   //「new 型」や「new 型()」で確保したときに返ってきたポインタ
delete[] ポインタ3; //「new 型[n]」で確保したときに返ってきたポインタ
```
※ `new 型[n]`で確保したメモリを`delete ポインタ`のようにしたり、 明示的に確保した領域以外を指すポインタに対して`delete`してはいけない


```cpp showLineNumbers filename="1つ分の領域を確保する"
#include <bits/stdc++.h>
using namespace std;

int main() {
  uint32_t *p;

  // uint32_t型の変数の分だけヒープ領域からメモリを確保する
  p = new uint32_t;

  // ポインタを介して使う
  *p = 123;
  cout << *p << endl;

  // メモリを解放する
  delete p;
}
```


```cpp showLineNumbers filename="連続した領域を確保する"
#include <bits/stdc++.h>
using namespace std;

int main() {
  uint32_t *p;

  // uint32_t型の変数10個分だけ(つまり4*10=40バイト分)ヒープ領域からメモリを確保する
  p = new uint32_t[10];

  // ポインタを介して使う
  uint32_t *tmp = p;  // アドレス値のコピー
  for (int i = 0; i < 10; i++) {
    *tmp = i; // i番目にiを書き込む
    tmp++; // 次の要素を指すように変更
  }

  tmp = p;  // pの位置に戻す
  for (int i = 0; i < 10; i++) {
    cout << *tmp << endl;
    tmp++;
  }

  // メモリを解放する(10個分連続で確保したのでdelete[]を使う)
  delete[] p;
}
```

## メモリアクセスの制約
- ポインタを通して好きな位置に値を書き込んだり読み込んだりできるかと言うと、そうではありません。 
- 基本的に「変数のために確保されたメモリ領域」か「明示的に確保したメモリ領域」にしかアクセスしてはいけません。 
- めちゃくちゃなアドレスに対して無理やり書き込み・読み込みを行おうと試みるのは意図しない挙動に繋がります。
- ポインタを扱うプログラムを書く場合は、許されていないメモリ領域にアクセスしていないかを常に気をつける必要があります。 
- この意味で、ポインタを扱うプログラムは難しいと言えます。


### ポインタ宣言における`*`の位置
```cpp 
型 *ポインタ名
型* ポインタ名
型 * ポインタ名
```

## nullptr
- ポインタが初期化されていないことを明示したり、有効なアドレスを指していないことを明示するための 特殊な値としてnullptrを用いることができます。
- nullptrは多くの場合0を意味します。
```cpp
if (ポインタ) {
  (nullptrでないとき)
} else {
  (nullptrのとき)
}
```
```cpp showLineNumbers
#include <bits/stdc++.h>
using namespace std;

int main() {
  uint8_t x = 1;
  uint8_t *p = nullptr;  // 初期値として nullptr を使う
  p = &x;
  *p = 2;
  p = nullptr;  // 使い終わったポインタには nullptr を入れておく
  cout << (int)x << endl;  // 2

  if (p) {
    cout << "not nullptr" << endl;
  } else {
    cout << "nullptr" << endl;
  }
}
```

## 複数バイトの変数
- 1バイトより大きいデータは複数のバイトに分割されて保存されます。
> 例えば、12345という数値を保存することを考えてみます。 
この数値は1バイト(0~255)の範囲に収まらないデータなので、「57」と「48」という数に分割し、2バイトに分けて保存することにします。 
すると、57 + 48 * 256 = 12345として元の値を復元することができます。


## アドレス値の加減算
- ポインタ(自体の値)に対して加減算を行うことで「その分だけずらした位置を指すポインタ」を得ることができます。 
- メモリを連続的に確保し配列のように用いる際に、ポインタの加減算は有用です。
```cpp showLineNumbers filename="int型10要素分のメモリを確保し、順番にアクセス"
#include <bits/stdc++.h>
using namespace std;

int main() {
  // int型10要素分をヒープ領域から確保(先頭のアドレスがpに入っている)
  int *p = new int[10];
  int *q = nullptr; // newをつかっていない、ポインタであり、ヒープの確保はしていない

  for (int i = 0; i < 10; i++) {
    q = p + i;  // i番目の要素のポインタを取得
    *q = i;  // q の指す位置に i を書き込む
  }

  q = p;
  for (int i = 0; i < 10; i++) {
    cout << *q << endl;
    q++; // q = q + 1と同じ意味(次の要素を指すポインタに変更)
  }

  delete[] p;  // メモリ解放
}
```

## 参照とイテレータの関係
- 参照とイテレータは「ポインタ」簡単に使うために用意された機能
- 以下同じことをしているが、ポインタを使う必要はない
```cpp showLineNumbers filename="参照としてポインタを使う"
#include <bits/stdc++.h>
using namespace std;

void f(int &ref) {
  ref = 2;
}

// ポインタを用いた参照渡し
void g(int *ptr) {
  *ptr = 2;
}

int main() {
  int x = 1;
  f(x);  // 参照渡し
  cout << x << endl; // 2

  int y = 1;
  g(&y);  // yのアドレスを渡す
  cout << y << endl; // 2
}
```

```cpp showLineNumbers filename="イテレータとしてポインタを使う"
#include <bits/stdc++.h>
using namespace std;

int main() {
  // イテレータを用いて順番にアクセス
  vector<int> a = { 1, 2, 3 };
  for (auto it = a.begin(); it != a.end(); it++) {
    cout << *it << endl;
  }

  // ポインタを用いて順番にアクセス
  vector<int> b = { 1, 2, 3 };
  // b.data() ... bのデータの先頭アドレスを返す(&b[0] と同じ)
  int *begin_addr = b.data();
  for (int *ptr = begin_addr; ptr < begin_addr + 3; ptr = ptr + 1) {
    cout << *ptr << endl;
  }
}
```

## voidポインタ
-  voidへのポインタは任意のポインタ値を扱うことができる
- voidへのポインタは、指す先へのアクセスを行うことはできません。 アクセスを行うには元のポインタ型にキャストする必要があります。
- コンパイラは元々のポインタ型が何であったかをチェックしてくれないので、 voidポインタを扱うときはプログラマが責任を持って元の型を管理する必要があります。

```cpp showLineNumbers filename="voidポインタの配列に色々なオブジェクトへのポインタを入れる例"
#include <bits/stdc++.h>
using namespace std;

int main() {
  int x = 123;
  string y = "hello";
  double z = 4.5;

  // voidポインタの配列 順番に int*, string*, double* 型のポインタ
  vector<void *> ptrs = { &x, &y, &z };

  int *xp = (int *)ptrs[0];
  string *yp = (string *)ptrs[1];
  double *zp = (double *)ptrs[2];
  cout << *xp << endl; // 123
  cout << *yp << endl; // hello
  cout << *zp << endl; // 4.5
}
```


## ポインタの使い所
> ポインタは参照やイテレータがある分、C++では使いどころが思いつかないかもしれません。
ヒープ領域の確保が絡んだときにポインタが真価を発揮すると言えるでしょう。 従って、メモリを効率的に使いたい場合にはポインタが必要になります。
また、競技プログラミングにおいても木構造やグラフなどのデータ構造を表現するときに ポインタを用いると便利なことがあります。 競技プログラミングを初めたばかりのうちはポインタが必要になるケースはほとんどないと思いますが、 将来使うことがあったら思い出してみてください。



## スマートポインタ
- メモリ確保を簡単にするためのライブラリ
- 
```cpp showLineNumbers filename="std::unique_ptr"
#include <bits/stdc++.h>
using namespace std;

int main() {
  // int型1つ分の領域を確保(123で初期化)
  unique_ptr<int> p1 = make_unique<int>(123);
  *p1 += 1;
  cout << *p1 << endl; // 124

  unique_ptr<int> p2;
  p2 = move(p1); // メモリの所有権をp2に移動
  //*p1 += 10;  // p1は所有権を失ったのでエラー
  *p2 += 1;
  cout << *p2 << endl; // 125
}  // ここでp2の持っていた所有権が無効になり自動的にメモリが回収される

```
```cpp showLineNumbers filename="std::shared_ptr"
#include <bits/stdc++.h>
using namespace std;

int main() {
  shared_ptr<int> p3;
  {
    shared_ptr<int> p1 = make_shared<int>(123);
    {
      shared_ptr<int> p2 = p1;  // p2も所有権を共有
      *p2 += 1;
      p3 = p2;  // p3も所有権を共有
    } // p2が所有権を手放す(p1, p3が共有している状態)
    *p1 += 1;
  } // p1が所有権を手放す(p3が持っている状態)
  *p3 += 1;
  cout << *p3 << endl; // 126
} // 所有者がいなくなり、メモリが解放される

```
> std::shared_ptrには循環参照が生じた場合にメモリが回収できなくなるという問題があります。 この場合std::weak_ptrを用いることで循環参照を回避できるようになっています。