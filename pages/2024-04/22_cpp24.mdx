# ビット演算
## キーポイント
- 「0」か「1」の2通りの状態を表現することができるデータの単位をビットといい、ビットを複数並べたものをビット列という
- ビット演算を用いると集合を便利に扱えることがある
- C++でビット列を扱うときは`bitset`を用いる
```cpp
bitset<ビット数> 変数名;  // すべてのビットが0の状態で初期化される
bitset<ビット数> 変数名("ビット列(長さはビット数に合わせる)");  // 指定したビット列で初期化される

変数.set(位置, 値);  // ビットの値を変更
変数.test(位置);  // ビットの値を調べる
```
- 次の表のようなビット列に関する演算をビット演算という

|ビット演算|演算子|意味|
|---|---|---|
|AND|`&`|各ビットについて「両方のビットが1ならば1」という操作を適用する|
|OR|`\|`|各ビットについて「少なくとも一方のビットが1ならば1」という操作を適用する|
|XOR|`^`|各ビットについて「どちらか一方だけが1ならば1」という操作を適用する|
|NOT|`~`|各ビットについて「ビットを反転する」という操作を適用する|
|左シフト演算|`<<`|指定したビット数だけビット列を左にずらす。範囲外のビットは切り捨て、足りないビットは0埋め|
|右シフト演算|`>>`|指定したビット数だけビット列を右にずらす。範囲外のビットは切り捨て、足りないビットは0埋め|


- C++の整数型を用いることで(通常)64ビットまでのビット列を扱うことができる
- ビット演算の演算子は優先順位を間違えやすいため、明示的に()でくくるようにする

# ビット演算の使い道
## 集合の操作
- 集合にある要素が含まれる状態`1`含まれない状態を`0`として扱う
- $A = \{ 2, 3, 7\}$ → `0110001000`, $B = \{ 1, 2, 3 \}$ → `1110000000`, $A \cap B = \{ 2, 3 \}$ → `0110000000`(and演算)

## 高速化
ビット演算では複数のビットについての計算をまとめて行えるので、 この性質をうまく活かすとプログラムを高速化できることがあります


# STLのbitset
```cpp showLineNumbers 
#include <bits/stdc++.h>
using namespace std;

int main() {
  bitset<8> a("00011011");
  bitset<8> b("00110101");

  auto c = a & b;
  cout << "1: " << c << endl;         // 1: 00010001
  cout << "2: " << (c << 1) << endl;  // 2: 00100010
  cout << "3: " << (c << 2) << endl;  // 3: 01000100
  cout << "4: " << (c << 3) << endl;  // 4: 10001000
  cout << "5: " << (c << 4) << endl;  // 5: 00010000

  c <<= 4;
  c ^= bitset<8>("11010000"); // XOR演算の複合代入演算子
  cout << "6: " << c << endl; // 6: 11000000
}
```
# bitsetの操作
```cpp showLineNumbers
#include <bits/stdc++.h>
using namespace std;
int main() {
  bitset<4> S;
  S.set(0, 1);  // 0番目のビットを1にする
  cout << S << endl;

  if (S.test(3)) {
    cout << "4th bit is 1" << endl;
  } else {
    cout << "4th bit is 0" << endl;
  }
}
```
```cpp filename="実行結果"
0001
4th bit is 0
```

# ビットの全探索
- ビット全探索とは「すべてのビット列の組合せ」に対して何らかの処理を行うことをいいます。
```cpp showLineNumbers
#include <bits/stdc++.h>
using namespace std;

int main() {
  // 3ビットのビット列をすべて列挙する
  for (int tmp = 0; tmp < (1 << 3); tmp++) {
    bitset<3> s(tmp);
    // ビット列を出力
    cout << s << endl;
  }
}
```
- for文は0から8になるまで
- `1 << 3` = 1を3ビット左シフトすると、ビット列は「1000」= `8`
- 2のk乗の値を得るために、`1 << k`という書き方をすることがよくあります。シンプルな形なので覚えておきましょう
```cpp filename="全探索の雛形"
for (int tmp = 0; tmp < (1 << ビット数); tmp++) {
  bitset<ビット数> s(tmp);
  // (ビット列sに対する処理)
}
```

# 2進数リテラル
- 2進数リテラルを用いることで、2進数表記で整数を書くことができる
- 2進数リテラルは`0b0101`や`0b11111111`のように、`0b`に続けて01のビット列を書く

