# fetchAPIã®ä½¿ã„æ–¹2

## OSSã§è§£æ±ºã™ã‚‹

### Axios
- äººæ°—ã®ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚§ãƒƒãƒãƒ³ã‚°ãƒ©ã‚¤ãƒ–ãƒ©ãƒª
- ãƒ¬ã‚¹ãƒãƒ³ã‚¹æƒ…å ±ã‚’è‡ªå‹•ã§errorãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã—ã¦ãã‚Œã‚‹
```js filename="axios"
try {
  const { data } = await axios.get('/user')
} catch (err) {
  // Handle issues via error.response.*
}
```

### Redaxios
- ä¸€è¨€ã§ã„ã†ã¨ã€Œã‚ˆã‚Šãƒ¢ãƒ€ãƒ³ãªAxiosã€
- Axiosã¯ã„ã„ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã ãŒãƒ‡ãƒ¼ã‚¿ãƒ•ã‚§ãƒƒãƒãƒ³ã‚°ã ã‘ã«ã—ã¦ã¯ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã‚‹
- AxiosãŒ`11kb`ã«å¯¾ã—ã€Redaxiosãªã‚‰`1kb`ä»¥ä¸‹
- ä½¿ã„æ–¹ãŒåŒã˜ã§importæ–‡ã‚’å¤‰æ›´ã™ã‚‹ã ã‘
```js filename="Redaxios"
import axios from 'redaxios'
// use as you would normally
```


### Wretch
```js filename="é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°çš„ã«è¨˜è¿°ã§ãã‚‹"
const user = await wretch("/user")
  .get()
  // Handle error cases in a more human-readable way
  .notFound(error => { /* ... */ })
  .unauthorized(error => { /* ... */ })
  .error(418, error => { /* ... */ })
  .res(response => /* ... */)
  .catch(error => { /* uncaught errors */ })
```


## æ­£ã—ããƒ‡ãƒ¼ã‚¿ã‚’æ›¸ã
```js filename="ã©ã“ãŒé–“é•ã£ã¦ã„ã‚‹ã‹ï¼Ÿ"
const res = await fetch('/user', {
  method: 'POST',
  body: { name: 'Steve Sewell', company: 'Builder.io' }
})
```

- `body`ã¯JSONã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã—ã‚ˆã†
```js
const res = await fetch('/user', {
  method: 'POST',
  // âœ… We must JSON-serialize this body
  body: JSON.stringify({ name: 'Steve Sewell', company: 'Builder.io' })
})
```

- `headers`ã‚’æ¸¡ãã†
<br/>â†’ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¯`headers`ãŒç„¡ã‘ã‚Œã°ãã‚‚ãã‚‚å—ã‘å–ã‚‰ãªã„è¨€èªãƒ»ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ãŒå¤šã„
```js
const res = await fetch('/user', {
  headers: {
    // âœ… If we are sending serialized JSON, we should set the Content-Type:
    'Content-Type': 'application/json'
  },
  method: 'POST',
  body: JSON.stringify({ name: 'Steve Sewell', company: 'Builder.io' })
})
```


## è‡ªå‹•çš„ã«JSONã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹
- æ¯å›`headers`ã‚„`JSON.stringify`ã‚’ã™ã‚‹ãªã‚‰wrapã—ã¦ã—ã¾ã†
```js
const isPlainObject = value => value?.constructor === Object

export async function myFetch(...options) {
  let initOptions = options[1]
  // If we specified a RequestInit for fetch
  if (initOptions?.body) {
    // If we have passed a body property and it is a plain object or array
    if (Array.isArray(initOptions.body) || isPlainObject(initOptions.body)) {
      // Create a new options object serializing the body and ensuring we
      // have a content-type header
      initOptions = {
        ...initOptions,
        body: JSON.stringify(initOptions.body),
        headers: {
          'Content-Type': 'application/json',
          ...initOptions.headers
        }
      }
    }
  }

  const res = await fetch(...initOptions)
  if (!res.ok) {
    throw new ResponseError('Bad fetch response', res)
  }
  return res
}
```
â€» è‰¯ã„å…±é€šåŒ–(ã‚¢ãƒ–ã‚¹ãƒˆãƒ©ã‚¯ã‚·ãƒ§ãƒ³)ã¯ãƒ†ãƒ³ãƒ—ãƒ¬ä½œæ¥­ã‚’çœãã€ã‚¨ãƒ©ãƒ¼ã‚’é˜²ãã€‚å‘¼ã³å‡ºã—å´ã«ä¾å­˜ã—ãªã„äº‹ãŒé‡è¦ã€‚
â†“
```js filename="ä½¿ã†"
const res = await myFetch('/user', {
  method: 'POST',
  body: { name: 'Steve Sewell', company: 'Builder.io' }
})
```


### OSSãªã‚‰Wrapperã—ã¦ãã‚Œã‚‹
```js filename="axios Redaxios"
const res = await axios.post('/user', {
  name: 'Steve Sewell', company: 'Builder.io' 
})
```

```js filename="Wretch"
const res = await wretch('/user').post({ 
  name: 'Steve Sewell', company: 'Builder.io' 
})
```


## Wrapperã®å‹å®‰å…¨
- typeScriptã‚’ä½¿ãŠã†
- `const initOption = someArray[1]`ã®ã‚ˆã†ãªäºˆæ¸¬ã¯åŸºæœ¬çš„ã«ã‚ˆã‚ã—ããªã„
```js filename="wrapper with TS"
const isPlainObject = (value: unknown) => value?.constructor === Object

class ResponseError extends Error {
  response: Response

  constructor(message: string, res: Response) {
    super(message)
    this.response = res
  }
}

export async function myFetch(input: RequestInfo | URL, init?: RequestInit): Promise<Response> {
  let initOptions = init
  // If we specified a RequestInit for fetch
  if (initOptions?.body) {
    // If we have passed a body property and it is a plain object or array
    if (Array.isArray(initOptions.body) || isPlainObject(initOptions.body)) {
      // Create a new options object serializing the body and ensuring we
      // have a content-type header
      initOptions = {
        ...initOptions,
        body: JSON.stringify(initOptions.body),
        headers: {
          "Content-Type": "application/json",
          ...initOptions.headers,
        },
      }
    }
  }

  const res = await fetch(input, initOptions)
  if (!res.ok) {
    throw new ResponseError("Bad response", res)
  }
  return res
}
```

## catchã—ãŸerrã¯unknownã‚¿ã‚¤ãƒ—ã‚’ä½¿ãŠã†(23å¹´ç¾åœ¨ã§ã¯æ­´å²ã®è©±)
- â€»ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§`unknown`ã ãŒã€ä»¥å‰ã¯`any`
- `any`ã ã¨`err.respose.status`ãªã©ã‚’æŒã£ã¦ã„ã‚‹ã‹ã‚ã‹ã‚‰ãªã„
- `err`ã«ã¯ã©ã‚“ãªå‹ã‚‚ã‚ã‚Šãˆã‚‹ãŸã‚ä»¥ä¸‹ã®ã‚ˆã†ã«å‹ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã—ã¦ã¯ã„ã‘ãªã„
```js
try {
  const res = await myFetch
} catch (err: ResponseError) {
  // ğŸš© TS error 1196: Catch clause variable type annotation must be 'any' or 'unknown' if specified
}
```
â†’ errã«ã¯`unknown`ã‚’ä½¿ãŠã†(ä»Šã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)

```js
try {
  const res = await myFetch('/user')
  const user = await res.body()
} catch (err: unknown) {
  if (err instanceof ResponseError) {
    // Nice and type-safe!
    switch (err.response.status) { ... }
  } else {
    throw new Error('An unknown error occured when fetching the user', {
      cause: err
    })
}
```
â†’ `instanceof`ã‚’ä½¿ã£ã¦ã„ã‚‹ã‹ã‚‰é–‹ç™ºæ™‚ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æ±ºå®šã—ã¦ãã‚Œã‚‹


### ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚‚å…±é€šåŒ–ã™ã‚‹
```js {14}
try {
  const res = await myFetch('/user')
  const user = await res.body()
} catch (err) {
  if (err instanceof ResponseError) {
    if (err.response.status === 404) {
      // Special logic unique to this call where we want to handle this status,
      // like to say on a 404 that we seem to not have this user
      return
    }
  }
  // â¬‡ï¸ Handle anything else that we don't need special logic for, and just want
  // our default handling
  handleError(err)
  return
}
```


```js
export function handleError(err: unkown) {
  // Safe to our choice of logging service
  saveToALoggingService(err);

  if (err instanceof ResponseError) {
    switch (err.response.status) {
      case 401:
        // Prompt the user to log back in
        showUnauthorizedDialog()
        break;
      case 500: 
        // Show user a dialog to apologize that we had an error and to 
        // try again and if that doesn't work contact support
        showErrorDialog()
        break;
      default:
        // Show 
        throw new Error('Unhandled fetch response', { cause: err })
    }
  } 
  throw new Error('Unknown fetch error', { cause: err })
}
```

### with OSS
```js filename="axios redaxios"
try {
  const { data: user } = await axios.get('/user')
} catch (err) {
  if (axios.isAxiosError(err)) {
    if (err.response.status === 404) {
      // Special not found logic
      return
    }
  }
  // Catch anything else with our default handler
  handleError(err)
  return
}
```

```js filename="Wretch"
try {
  const res = await wretch.get('/user')
    .notFound(() => { /* Special not found logic */ })
  const user = await res.body()
} catch (err) {
  // Catch anything else with our default handler
  handleError(err);
  return;
}
```