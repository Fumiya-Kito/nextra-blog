# Server Componentでデータフェッチを行う理由

## Clinet Componentでのデータフェッチのデメリット
1. 通信回数とシンプルな設計はトレードオフになりがち
  - `God API`: 責務が大きなAPI. 変更容易性やAPI自体のパフォーマンス問題が起きやすい
  - `Chatty API`: (おしゃべりなAPI)と呼ばれ、データフェッチをコロケーションしてカプセル化などのメリットを得られる一方、通信回数が増えたりデータフェッチのウォーターフォールが発生しやすく、Webアプリのパフォーマンス劣化を起こす

2. 実装コスト
- Reactはキャッシュするために3rd Partyライブラリを使う(学習しなければ)
- リクエスト先に当たるAPIは、パブリックなネットワークに公開するためより堅牢なセキュリティが求められる(学習しなければ)

3. バンドルサイズが増える
- データフェッチの実装・バリデーション・エラー時UIなどがフロントエンド担当しバンドルサイズが増える

4. セキュリティの煩雑さ
- CORS制約があり、認証情報の取り扱いが複雑。

## React Server Components 
- 上記の問題を含め、そもそも「Reactがサーバーをうまく利用できていない」という問題としてRSCアーキテクチャが誕生


## Server Componentでのデータフェッチのメリット
1. 高速なバックエンドアクセス
- Next.jsがホストされている環境（例: Vercel, AWS, GCPなど）とAPIサーバーが同じリージョン内にある場合、(クライアントより)物理的な距離が近い

2. シンプルな実装
```
export async function ProductTitle({ id }) {
  const res = await fetch(`https://dummyjson.com/products/${id}`);
  const product = await res.json();

  return <div>{product.title}</div>;
}
```

3. セキュアな実装
- データフェッチはサーバー側でのみ実行されるため、APIをパブリックなネットワークで公開することは必須ではない
- プライベートなネットワーク内でのみバックエンドAPIへアクセスするようにすれば、セキュリティリスクや対策コストを軽減

3. バンドルサイズの低減
- データフェッチの実装・バリデーション・エラー時UIなどはフロントエンドには不要

## Server Componentでのデータフェッチのメリット
1. ユーザー操作を伴うデータフェッチの実装は困難→`useActionState`を使用([参考](./07_data_fetching_with_userinteraction.mdx))

2. GraphQLとの相性の悪さ