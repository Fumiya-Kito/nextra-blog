# Git
仕事でGitの指南的なことをすることになったため個人的にも学んだことをメモ


## 背景
- 顧客がSVNからGitに移行したが、（さらにその背景としてオンプレからAWSに移行してGitを使わざるを得なかった）いまいち使い方や運用方法が定まっていない
- 特に、SIerである我々の納品方法がクラウドストレージBoxに手作業で成果物を納品していたことが気になったため、GitHubフロー的に納品させてもらえないかを提案することに

## 提案するにあたって、学んだこと
1. ブランチ設計思想
2. マージ戦略
3. リリースブランチ作成方法
4. フェッチ・チェックアウトの定義再確認
5. 作業ツリーについて、操作コマンド


### 1. ブランチ設計思想
- `main, stg, dev, feature/` で分ける方法の他に、`release/`ブランチを使ったフロー（設計思想）がある
- 後者のメリット
1. リリース単位が明確になる
2. リリースでバグ修正を来ないつつ、devでは機能開発を実行できる
3. `hotfix`が運用しやすい(mainから切って、`main`と`dev`にマージできる)
- 後者のデメリット
1. ブランチ数が増えて煩雑になりやすい
2. ステージング環境が別に必要

- プロジェクト背景として、常に複数案件が走っているような状況で、案件を統合してリリースすることがあるためステージングブランチではなく、リリースブランチで提案

#### マージ戦略
Amazon-CodeCommit上のPR作成時に選択できるマージ戦略は以下
1. Fast-Forward merge (--ff-only)
2. squash merge (--squash)
3.  merge (--no-ff)

##### FFマージ
- 自分の変更分を直線的に追加するマージ戦略
- `main←release`マージにおいて、`mainの履歴=releaseの履歴`にするということ
- releaseの変更分の親コミットがmain含まれていてかつ分岐がない場合のみ使用可能

##### squashマージ
- PR内のコミット(マージ元と先の差分)をすべて1コミットとしてマージする戦略
- 履歴をスッキリさせたい時に推奨 (不要な中間コミットを履歴に残さない かつ 履歴を分岐させない)
- 個々のコミット情報は失われるし、マージ元とコミット履歴が異なることになる点に注意

##### wayマージ
- マージコミットを作成してマージする戦略
- 複数のコミットがまとまったことが履歴でわかりやすい
- マージコミットを繰り返すとログがみにくくなることに注意

